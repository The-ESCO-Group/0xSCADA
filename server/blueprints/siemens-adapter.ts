/**
 * Siemens Adapter
 * Handles parsing and generation for TIA Portal, SCL, and S7 formats
 */

import type { ParsedCMType, ParsedPhaseType, CMTypeInput, CMTypeOutput } from "./types";

// Siemens-specific data type mappings
export const siemensDataTypes: Record<string, string> = {
  Bool: "Bool",
  Int: "Int",
  DInt: "DInt",
  Real: "Real",
  LReal: "LReal",
  String: "String",
  Time: "Time",
  Date: "Date",
  DateTime: "Date_And_Time",
  Word: "Word",
  DWord: "DWord",
  Byte: "Byte",
  USInt: "USInt",
  UInt: "UInt",
  UDInt: "UDInt",
  SInt: "SInt",
};

// Siemens Function Block structure
export interface SiemensFB {
  name: string;
  title?: string;
  version: string;
  author?: string;
  family?: string;
  inputs: SiemensVariable[];
  outputs: SiemensVariable[];
  inOuts: SiemensVariable[];
  statics: SiemensVariable[];
  temps: SiemensVariable[];
  code: string;
}

export interface SiemensVariable {
  name: string;
  dataType: string;
  initialValue?: string;
  comment?: string;
  retain?: boolean;
}

/**
 * Convert a canonical CM Type to Siemens Function Block
 */
export function cmTypeToFB(cmType: ParsedCMType): SiemensFB {
  return {
    name: cmType.name,
    version: "1.0",
    inputs: cmType.inputs.map(i => ({
      name: i.name,
      dataType: translateToSiemens(i.dataType),
      comment: i.comment,
    })),
    outputs: cmType.outputs.map(o => ({
      name: o.name,
      dataType: translateToSiemens(o.dataType),
      comment: o.comment,
    })),
    inOuts: cmType.inOuts.map(io => ({
      name: io.name,
      dataType: translateToSiemens(io.dataType),
      comment: io.comment,
    })),
    statics: [],
    temps: [],
    code: generateDefaultSCLCode(cmType),
  };
}

/**
 * Convert a Phase Type to Siemens Function Block
 */
export function phaseTypeToFB(phaseType: ParsedPhaseType): SiemensFB {
  const inputs = (phaseType.inputs || []).map(i => ({
    name: i.name,
    dataType: translateToSiemens(i.dataType),
    comment: i.comment,
  }));

  const outputs = (phaseType.outputs || []).map(o => ({
    name: o.name,
    dataType: translateToSiemens(o.dataType),
    comment: o.comment,
  }));

  const inOuts = (phaseType.inOuts || []).map(io => ({
    name: io.name,
    dataType: translateToSiemens(io.dataType),
    comment: io.comment,
  }));

  // Add linked modules as InOuts
  for (const lm of phaseType.linkedModules || []) {
    inOuts.push({
      name: lm.name,
      dataType: lm.type,
      comment: `Linked ${lm.type} module`,
    });
  }

  // Internal values become static variables
  const statics = (phaseType.internalValues || []).map(iv => ({
    name: iv.name,
    dataType: translateToSiemens(iv.dataType),
    comment: iv.comment,
  }));

  // Add state machine variables
  statics.push(
    { name: "CurrentState", dataType: "Int", comment: "Current state machine state" },
    { name: "CurrentStep", dataType: "Int", comment: "Current step within state" },
    { name: "StepTimer", dataType: "Time", comment: "Step timing" }
  );

  return {
    name: phaseType.name,
    version: "1.0",
    inputs,
    outputs,
    inOuts,
    statics,
    temps: [],
    code: generatePhaseSCLCode(phaseType),
  };
}

/**
 * Translate canonical data type to Siemens type
 */
export function translateToSiemens(canonicalType: string): string {
  return siemensDataTypes[canonicalType] || canonicalType;
}

/**
 * Translate Siemens data type to canonical type
 */
export function translateFromSiemens(siemensType: string): string {
  const reverseMap: Record<string, string> = {};
  for (const [canonical, siemens] of Object.entries(siemensDataTypes)) {
    reverseMap[siemens] = canonical;
  }
  return reverseMap[siemensType] || siemensType;
}

/**
 * Generate default SCL code for a Control Module
 */
function generateDefaultSCLCode(cmType: ParsedCMType): string {
  const lines: string[] = [];
  lines.push(`// ${cmType.name} - Control Module Logic`);
  lines.push(`// Generated by 0xSCADA Blueprints Engine`);
  lines.push("");
  lines.push("// Input Processing");
  
  for (const input of cmType.inputs) {
    if (input.primary) {
      lines.push(`// Primary Input: #${input.name}`);
    }
  }
  
  lines.push("");
  lines.push("// Main Control Logic");
  lines.push("// TODO: Implement control algorithm");
  lines.push("");
  lines.push("// Output Processing");
  
  for (const output of cmType.outputs) {
    if (output.primary) {
      lines.push(`// Primary Output: #${output.name}`);
    }
  }

  return lines.join("\n");
}

/**
 * Generate SCL code for a Phase Type with state machine
 */
function generatePhaseSCLCode(phaseType: ParsedPhaseType): string {
  const lines: string[] = [];
  lines.push(`// ${phaseType.name} - Phase Logic`);
  lines.push(`// Generated by 0xSCADA Blueprints Engine`);
  lines.push("");
  lines.push("// ISA-88 State Machine");
  lines.push("CASE #CurrentState OF");
  lines.push("");
  
  // Generate state handlers
  const states = ["IDLE", "STARTING", "RUNNING", "PAUSING", "PAUSED", "HOLDING", "HELD", "RESTARTING", "STOPPING", "STOPPED", "ABORTING", "ABORTED", "COMPLETING", "COMPLETE"];
  
  for (let i = 0; i < states.length; i++) {
    const state = states[i];
    lines.push(`    ${i}: // ${state}`);
    
    // Check if we have sequence logic for this state
    const sequences = phaseType.sequences as Record<string, any>;
    const stateKey = state.charAt(0) + state.slice(1).toLowerCase();
    
    if (sequences && sequences[stateKey] && sequences[stateKey].steps) {
      lines.push(`        CASE #CurrentStep OF`);
      for (const step of sequences[stateKey].steps) {
        lines.push(`            ${step.step}:`);
        for (const action of step.actions || []) {
          lines.push(`                // ${action}`);
        }
        lines.push(`                ;`);
      }
      lines.push(`        END_CASE;`);
    } else {
      lines.push(`        // ${state} state logic`);
      lines.push(`        ;`);
    }
    lines.push("");
  }
  
  lines.push("END_CASE;");

  return lines.join("\n");
}

/**
 * Generate complete SCL Function Block source
 */
export function generateSCLSource(fb: SiemensFB): string {
  const lines: string[] = [];
  
  lines.push(`// Function Block: ${fb.name}`);
  lines.push(`// Generated by 0xSCADA Blueprints Engine`);
  lines.push(`// Version: ${fb.version}`);
  lines.push(`// Date: ${new Date().toISOString()}`);
  lines.push("");
  lines.push(`FUNCTION_BLOCK "${fb.name}"`);
  lines.push(`{ S7_Optimized_Access := 'TRUE' }`);
  lines.push(`VERSION : ${fb.version}`);
  if (fb.author) lines.push(`AUTHOR : ${fb.author}`);
  if (fb.family) lines.push(`FAMILY : ${fb.family}`);
  lines.push("");
  
  // VAR_INPUT
  if (fb.inputs.length > 0) {
    lines.push("VAR_INPUT");
    for (const v of fb.inputs) {
      const comment = v.comment ? ` // ${v.comment}` : "";
      const init = v.initialValue ? ` := ${v.initialValue}` : "";
      lines.push(`    ${v.name} : ${v.dataType}${init};${comment}`);
    }
    lines.push("END_VAR");
    lines.push("");
  }
  
  // VAR_OUTPUT
  if (fb.outputs.length > 0) {
    lines.push("VAR_OUTPUT");
    for (const v of fb.outputs) {
      const comment = v.comment ? ` // ${v.comment}` : "";
      const init = v.initialValue ? ` := ${v.initialValue}` : "";
      lines.push(`    ${v.name} : ${v.dataType}${init};${comment}`);
    }
    lines.push("END_VAR");
    lines.push("");
  }
  
  // VAR_IN_OUT
  if (fb.inOuts.length > 0) {
    lines.push("VAR_IN_OUT");
    for (const v of fb.inOuts) {
      const comment = v.comment ? ` // ${v.comment}` : "";
      lines.push(`    ${v.name} : ${v.dataType};${comment}`);
    }
    lines.push("END_VAR");
    lines.push("");
  }
  
  // VAR (static)
  if (fb.statics.length > 0) {
    lines.push("VAR");
    for (const v of fb.statics) {
      const comment = v.comment ? ` // ${v.comment}` : "";
      const init = v.initialValue ? ` := ${v.initialValue}` : "";
      const retain = v.retain ? " RETAIN" : "";
      lines.push(`    ${v.name}${retain} : ${v.dataType}${init};${comment}`);
    }
    lines.push("END_VAR");
    lines.push("");
  }
  
  // VAR_TEMP
  if (fb.temps.length > 0) {
    lines.push("VAR_TEMP");
    for (const v of fb.temps) {
      const comment = v.comment ? ` // ${v.comment}` : "";
      lines.push(`    ${v.name} : ${v.dataType};${comment}`);
    }
    lines.push("END_VAR");
    lines.push("");
  }
  
  // BEGIN block
  lines.push("BEGIN");
  lines.push(fb.code.split("\n").map(l => `    ${l}`).join("\n"));
  lines.push("END_FUNCTION_BLOCK");
  
  return lines.join("\n");
}

/**
 * Generate TIA Portal XML export format
 */
export function generateTIAXML(fb: SiemensFB): string {
  const lines: string[] = [];
  
  lines.push(`<?xml version="1.0" encoding="utf-8"?>`);
  lines.push(`<Document>`);
  lines.push(`  <Engineering version="V17" />`);
  lines.push(`  <DocumentInfo>`);
  lines.push(`    <Created>${new Date().toISOString()}</Created>`);
  lines.push(`    <ExportSetting>WithDefaults</ExportSetting>`);
  lines.push(`    <InstalledProducts>`);
  lines.push(`      <Product>Totally Integrated Automation Portal</Product>`);
  lines.push(`    </InstalledProducts>`);
  lines.push(`  </DocumentInfo>`);
  lines.push(`  <SW.Blocks.FB ID="0">`);
  lines.push(`    <AttributeList>`);
  lines.push(`      <Name>${fb.name}</Name>`);
  lines.push(`      <Number>1</Number>`);
  lines.push(`      <ProgrammingLanguage>SCL</ProgrammingLanguage>`);
  lines.push(`    </AttributeList>`);
  lines.push(`    <ObjectList>`);
  
  // Interface section
  lines.push(`      <SW.Blocks.Interface.Sections>`);
  
  // Input section
  if (fb.inputs.length > 0) {
    lines.push(`        <Section Name="Input">`);
    for (const v of fb.inputs) {
      lines.push(`          <Member Name="${v.name}" Datatype="${v.dataType}">`);
      if (v.comment) {
        lines.push(`            <Comment><MultiLanguageText Lang="en-US">${v.comment}</MultiLanguageText></Comment>`);
      }
      lines.push(`          </Member>`);
    }
    lines.push(`        </Section>`);
  }
  
  // Output section
  if (fb.outputs.length > 0) {
    lines.push(`        <Section Name="Output">`);
    for (const v of fb.outputs) {
      lines.push(`          <Member Name="${v.name}" Datatype="${v.dataType}">`);
      if (v.comment) {
        lines.push(`            <Comment><MultiLanguageText Lang="en-US">${v.comment}</MultiLanguageText></Comment>`);
      }
      lines.push(`          </Member>`);
    }
    lines.push(`        </Section>`);
  }
  
  // InOut section
  if (fb.inOuts.length > 0) {
    lines.push(`        <Section Name="InOut">`);
    for (const v of fb.inOuts) {
      lines.push(`          <Member Name="${v.name}" Datatype="${v.dataType}">`);
      if (v.comment) {
        lines.push(`            <Comment><MultiLanguageText Lang="en-US">${v.comment}</MultiLanguageText></Comment>`);
      }
      lines.push(`          </Member>`);
    }
    lines.push(`        </Section>`);
  }
  
  // Static section
  if (fb.statics.length > 0) {
    lines.push(`        <Section Name="Static">`);
    for (const v of fb.statics) {
      lines.push(`          <Member Name="${v.name}" Datatype="${v.dataType}">`);
      if (v.comment) {
        lines.push(`            <Comment><MultiLanguageText Lang="en-US">${v.comment}</MultiLanguageText></Comment>`);
      }
      lines.push(`          </Member>`);
    }
    lines.push(`        </Section>`);
  }
  
  lines.push(`      </SW.Blocks.Interface.Sections>`);
  
  // Code section
  lines.push(`      <SW.Blocks.CompileUnit>`);
  lines.push(`        <AttributeList>`);
  lines.push(`          <ProgrammingLanguage>SCL</ProgrammingLanguage>`);
  lines.push(`        </AttributeList>`);
  lines.push(`        <ObjectList>`);
  lines.push(`          <SW.Blocks.CompileUnit.ProgramCode>`);
  lines.push(`            <StructuredText><![CDATA[${fb.code}]]></StructuredText>`);
  lines.push(`          </SW.Blocks.CompileUnit.ProgramCode>`);
  lines.push(`        </ObjectList>`);
  lines.push(`      </SW.Blocks.CompileUnit>`);
  
  lines.push(`    </ObjectList>`);
  lines.push(`  </SW.Blocks.FB>`);
  lines.push(`</Document>`);
  
  return lines.join("\n");
}

/**
 * Parse SCL source to extract Function Block definition
 * Simplified parser for basic SCL structure
 */
export function parseSCLSource(content: string): SiemensFB | null {
  // Extract FB name
  const nameMatch = content.match(/FUNCTION_BLOCK\s+"?([^"\s]+)"?/);
  if (!nameMatch) return null;

  const fb: SiemensFB = {
    name: nameMatch[1],
    version: "1.0",
    inputs: [],
    outputs: [],
    inOuts: [],
    statics: [],
    temps: [],
    code: "",
  };

  // Extract version
  const versionMatch = content.match(/VERSION\s*:\s*(\S+)/);
  if (versionMatch) fb.version = versionMatch[1];

  // Extract sections
  fb.inputs = parseVarSection(content, "VAR_INPUT");
  fb.outputs = parseVarSection(content, "VAR_OUTPUT");
  fb.inOuts = parseVarSection(content, "VAR_IN_OUT");
  fb.statics = parseVarSection(content, "VAR");
  fb.temps = parseVarSection(content, "VAR_TEMP");

  // Extract code between BEGIN and END_FUNCTION_BLOCK
  const codeMatch = content.match(/BEGIN([\s\S]*?)END_FUNCTION_BLOCK/);
  if (codeMatch) {
    fb.code = codeMatch[1].trim();
  }

  return fb;
}

/**
 * Parse a VAR section from SCL source
 */
function parseVarSection(content: string, sectionName: string): SiemensVariable[] {
  const variables: SiemensVariable[] = [];
  
  // Find section
  const sectionRegex = new RegExp(`${sectionName}([\\s\\S]*?)END_VAR`, "g");
  const sectionMatch = sectionRegex.exec(content);
  if (!sectionMatch) return variables;

  const sectionContent = sectionMatch[1];
  
  // Parse each variable line
  const varRegex = /(\w+)\s*:\s*(\w+)(?:\s*:=\s*([^;]+))?;(?:\s*\/\/\s*(.*))?/g;
  let varMatch;
  while ((varMatch = varRegex.exec(sectionContent)) !== null) {
    variables.push({
      name: varMatch[1],
      dataType: varMatch[2],
      initialValue: varMatch[3]?.trim(),
      comment: varMatch[4]?.trim(),
    });
  }

  return variables;
}
