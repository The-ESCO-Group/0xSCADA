/**
 * Rockwell Automation Adapter
 * Handles parsing and generation for Studio 5000, ControlLogix, and AOI formats
 */

import type { ParsedCMType, CMTypeInput, CMTypeOutput, CMTypeInOut } from "./types";

// Rockwell-specific data type mappings
export const rockwellDataTypes: Record<string, string> = {
  Bool: "BOOL",
  Int: "INT",
  DInt: "DINT",
  Real: "REAL",
  LReal: "LREAL",
  String: "STRING",
  Time: "TIMER",
  Counter: "COUNTER",
  Word: "INT",
  DWord: "DINT",
  Byte: "SINT",
  USInt: "USINT",
  UInt: "UINT",
  UDInt: "UDINT",
};

// Rockwell AOI structure
export interface RockwellAOI {
  name: string;
  description?: string;
  revision: string;
  vendor?: string;
  parameters: RockwellParameter[];
  localTags: RockwellLocalTag[];
  routines: RockwellRoutine[];
}

export interface RockwellParameter {
  name: string;
  dataType: string;
  usage: "Input" | "Output" | "InOut";
  required: boolean;
  visible: boolean;
  description?: string;
  default?: string;
}

export interface RockwellLocalTag {
  name: string;
  dataType: string;
  description?: string;
  default?: string;
}

export interface RockwellRoutine {
  name: string;
  type: "ST" | "Ladder" | "FBD" | "SFC";
  content: string;
}

/**
 * Convert a canonical CM Type to Rockwell AOI structure
 */
export function cmTypeToAOI(cmType: ParsedCMType): RockwellAOI {
  const parameters: RockwellParameter[] = [];
  const localTags: RockwellLocalTag[] = [];

  // Convert inputs to AOI parameters
  for (const input of cmType.inputs) {
    parameters.push({
      name: input.name,
      dataType: translateToRockwell(input.dataType),
      usage: "Input",
      required: input.primary || false,
      visible: true,
      description: input.comment,
    });
  }

  // Convert outputs to AOI parameters
  for (const output of cmType.outputs) {
    parameters.push({
      name: output.name,
      dataType: translateToRockwell(output.dataType),
      usage: "Output",
      required: output.primary || false,
      visible: true,
      description: output.comment,
    });
  }

  // Convert InOuts to AOI parameters
  for (const inOut of cmType.inOuts) {
    parameters.push({
      name: inOut.name,
      dataType: translateToRockwell(inOut.dataType),
      usage: "InOut",
      required: true,
      visible: true,
      description: inOut.comment,
    });
  }

  return {
    name: cmType.name,
    revision: "1.0",
    parameters,
    localTags,
    routines: [
      {
        name: "Logic",
        type: "ST",
        content: generateDefaultSTLogic(cmType),
      },
    ],
  };
}

/**
 * Translate canonical data type to Rockwell type
 */
export function translateToRockwell(canonicalType: string): string {
  return rockwellDataTypes[canonicalType] || canonicalType.toUpperCase();
}

/**
 * Generate default Structured Text logic for an AOI
 */
function generateDefaultSTLogic(cmType: ParsedCMType): string {
  const lines: string[] = [];
  lines.push(`// ${cmType.name} - Add-On Instruction Logic`);
  lines.push(`// Generated by 0xSCADA Blueprints Engine`);
  lines.push("");
  lines.push("// Input Processing");
  
  for (const input of cmType.inputs) {
    if (input.primary) {
      lines.push(`// Primary Input: ${input.name} (${input.dataType})`);
    }
  }
  
  lines.push("");
  lines.push("// Main Control Logic");
  lines.push("// TODO: Implement control algorithm");
  lines.push("");
  lines.push("// Output Processing");
  
  for (const output of cmType.outputs) {
    if (output.primary) {
      lines.push(`// Primary Output: ${output.name} (${output.dataType})`);
    }
  }

  return lines.join("\n");
}

/**
 * Generate L5X export format for AOI
 * L5X is Rockwell's XML-based import/export format
 */
export function generateL5X(aoi: RockwellAOI): string {
  const lines: string[] = [];
  
  lines.push(`<?xml version="1.0" encoding="UTF-8"?>`);
  lines.push(`<RSLogix5000Content SchemaRevision="1.0" SoftwareRevision="32.00" TargetName="${aoi.name}" TargetType="AddOnInstructionDefinition" ContainsContext="true" Owner="0xSCADA" ExportDate="{{EXPORT_DATE}}">`);
  lines.push(`  <Controller Use="Context" Name="0xSCADA_Export">`);
  lines.push(`    <AddOnInstructionDefinitions Use="Context">`);
  lines.push(`      <AddOnInstructionDefinition Name="${aoi.name}" Revision="${aoi.revision}" RevisionExtension="0" Vendor="0xSCADA" ExecutePrescan="false" ExecutePostscan="false" ExecuteEnableInFalse="false" CreatedDate="{{CREATED_DATE}}" CreatedBy="0xSCADA" EditedDate="{{EDITED_DATE}}" EditedBy="0xSCADA">`);
  
  // Description
  if (aoi.description) {
    lines.push(`        <Description><![CDATA[${aoi.description}]]></Description>`);
  }
  
  // Parameters
  lines.push(`        <Parameters>`);
  for (const param of aoi.parameters) {
    const required = param.required ? "true" : "false";
    const visible = param.visible ? "true" : "false";
    lines.push(`          <Parameter Name="${param.name}" TagType="Base" DataType="${param.dataType}" Usage="${param.usage}" Radix="Decimal" Required="${required}" Visible="${visible}" ExternalAccess="Read/Write">`);
    if (param.description) {
      lines.push(`            <Description><![CDATA[${param.description}]]></Description>`);
    }
    if (param.default) {
      lines.push(`            <DefaultData Format="Decorated"><DataValue DataType="${param.dataType}" Value="${param.default}"/></DefaultData>`);
    }
    lines.push(`          </Parameter>`);
  }
  lines.push(`        </Parameters>`);
  
  // Local Tags
  lines.push(`        <LocalTags>`);
  for (const tag of aoi.localTags) {
    lines.push(`          <LocalTag Name="${tag.name}" DataType="${tag.dataType}" ExternalAccess="None">`);
    if (tag.description) {
      lines.push(`            <Description><![CDATA[${tag.description}]]></Description>`);
    }
    lines.push(`          </LocalTag>`);
  }
  lines.push(`        </LocalTags>`);
  
  // Routines
  lines.push(`        <Routines>`);
  for (const routine of aoi.routines) {
    lines.push(`          <Routine Name="${routine.name}" Type="${routine.type === "ST" ? "ST" : "RLL"}">`);
    if (routine.type === "ST") {
      lines.push(`            <STContent>`);
      lines.push(`              <Line Number="0"><![CDATA[${routine.content.split("\n").join("]]></Line>\n              <Line Number=\"0\"><![CDATA[")}]]></Line>`);
      lines.push(`            </STContent>`);
    }
    lines.push(`          </Routine>`);
  }
  lines.push(`        </Routines>`);
  
  lines.push(`      </AddOnInstructionDefinition>`);
  lines.push(`    </AddOnInstructionDefinitions>`);
  lines.push(`  </Controller>`);
  lines.push(`</RSLogix5000Content>`);
  
  // Replace date placeholders
  const now = new Date().toISOString();
  return lines.join("\n")
    .replace(/\{\{EXPORT_DATE\}\}/g, now)
    .replace(/\{\{CREATED_DATE\}\}/g, now)
    .replace(/\{\{EDITED_DATE\}\}/g, now);
}

/**
 * Parse Rockwell L5X file to extract AOI definition
 * This is a simplified parser - production would use proper XML parsing
 */
export function parseL5X(content: string): RockwellAOI | null {
  // Extract AOI name
  const nameMatch = content.match(/AddOnInstructionDefinition\s+Name="([^"]+)"/);
  if (!nameMatch) return null;

  const aoi: RockwellAOI = {
    name: nameMatch[1],
    revision: "1.0",
    parameters: [],
    localTags: [],
    routines: [],
  };

  // Extract revision
  const revMatch = content.match(/Revision="([^"]+)"/);
  if (revMatch) aoi.revision = revMatch[1];

  // Extract description
  const descMatch = content.match(/<Description><!\[CDATA\[([^\]]+)\]\]><\/Description>/);
  if (descMatch) aoi.description = descMatch[1];

  // Extract parameters (simplified regex parsing)
  const paramRegex = /<Parameter\s+Name="([^"]+)"[^>]*DataType="([^"]+)"[^>]*Usage="([^"]+)"[^>]*>/g;
  let paramMatch;
  while ((paramMatch = paramRegex.exec(content)) !== null) {
    aoi.parameters.push({
      name: paramMatch[1],
      dataType: paramMatch[2],
      usage: paramMatch[3] as "Input" | "Output" | "InOut",
      required: content.includes(`Required="true"`),
      visible: true,
    });
  }

  return aoi;
}

/**
 * Convert Rockwell AOI to canonical CM Type
 */
export function aoiToCMType(aoi: RockwellAOI): ParsedCMType {
  const inputs: CMTypeInput[] = [];
  const outputs: CMTypeOutput[] = [];
  const inOuts: CMTypeInOut[] = [];

  for (const param of aoi.parameters) {
    const item = {
      name: param.name,
      dataType: translateFromRockwell(param.dataType),
      comment: param.description,
    };

    switch (param.usage) {
      case "Input":
        inputs.push(item as CMTypeInput);
        break;
      case "Output":
        outputs.push(item as CMTypeOutput);
        break;
      case "InOut":
        inOuts.push(item as CMTypeInOut);
        break;
    }
  }

  return {
    name: aoi.name,
    inputs,
    outputs,
    inOuts,
  };
}

/**
 * Translate Rockwell data type to canonical type
 */
export function translateFromRockwell(rockwellType: string): string {
  const reverseMap: Record<string, string> = {};
  for (const [canonical, rockwell] of Object.entries(rockwellDataTypes)) {
    reverseMap[rockwell] = canonical;
  }
  return reverseMap[rockwellType] || rockwellType;
}

/**
 * Generate Ladder Logic rung for a simple control module
 * Returns an array of rung definitions
 */
export function generateLadderRungs(cmType: ParsedCMType): string[] {
  const rungs: string[] = [];
  
  // Generate enable/disable rung
  rungs.push(`XIC(Enable)OTE(Enabled);`);
  
  // Generate fault detection rung
  const faultInputs = cmType.inputs.filter(i => i.isError);
  if (faultInputs.length > 0) {
    const faultConditions = faultInputs.map(f => `XIC(${f.name})`).join("");
    rungs.push(`${faultConditions}OTE(Fault);`);
  }
  
  // Generate output rungs
  for (const output of cmType.outputs) {
    if (output.primary) {
      rungs.push(`XIC(Enabled)XIO(Fault)OTE(${output.name});`);
    }
  }

  return rungs;
}
